// Generated by CoffeeScript 1.6.2
(function() {
  var chart, geocode, myDirectives;

  myDirectives = angular.module('myDirectives', []);

  myDirectives.directive('pickdateJs', function() {
    return {
      restrict: 'A',
      require: '?ngModel',
      link: function(scope, element, attrs, ngModel) {
        var picker;

        element.pickadate();
        picker = element.pickadate('picker');
        if (attrs.min) {
          scope.$watch(attrs.min, function(value) {
            return picker.set('min', value.toDate ? value.toDate() : value);
          });
        }
        if (attrs.max) {
          scope.$watch(attrs.max, function(value) {
            return picker.set('max', value.toDate ? value.toDate() : value);
          });
        }
        picker.on('close', function() {
          return scope.$apply(function() {
            var date, m;

            date = picker.get('select');
            m = moment(date.obj);
            ngModel.$modelValue = m;
            ngModel.$setViewValue(m.format());
            return ngModel.$render();
          });
        });
        ngModel.$formatters.unshift(function(modelValue) {
          if (!modelValue) {
            return "";
          }
          return moment(modelValue).format();
        });
        return ngModel.$parsers.unshift(function(viewValue) {
          if (!viewValue) {
            return "";
          }
          return moment(viewValue);
        });
      }
    };
  });

  chart = ['$filter'];

  chart.push(function($filter) {
    return {
      restrict: 'E',
      template: '<div class="chart"></div>',
      transclude: true,
      replace: true,
      link: function(scope, element, attrs) {
        var chartsDefaults;

        chartsDefaults = {
          chart: {
            renderTo: element[0],
            type: attrs.type || null,
            animation: Highcharts.svg,
            height: attrs.height || 200,
            width: attrs.width || 278,
            marginRight: 10
          },
          credits: {
            enabled: false
          },
          title: false,
          tooltip: {
            formatter: function() {
              var m;

              m = moment(this.x);
              return $filter('speed')([this.y]);
            }
          },
          xAxis: {
            type: "datetime",
            tickPixelInterval: 100
          },
          yAxis: {
            title: false,
            min: 0
          },
          legend: {
            enabled: false
          },
          series: [
            {
              name: 'Speed',
              data: []
            }
          ]
        };
        chart = new Highcharts.Chart(chartsDefaults);
        scope.$watch(attrs.trigger, function(trigger) {
          var data, s;

          data = scope.$eval(attrs.serie) || [];
          data.pop();
          s = chart.series[0];
          return s.setData(data);
        });
        return scope.$watch(attrs.last, function(last) {
          var s, _ref;

          if (!last) {
            return;
          }
          s = chart.series[0];
          if (last.first - ((_ref = s.data.last) != null ? _ref.x : void 0) > 50000) {
            s.setData([]);
          }
          return s.addPoint(last, true, s.data.length > 10);
        }, true);
      }
    };
  });

  myDirectives.directive('chart', chart);

  myDirectives.directive('currentTime', function() {
    return function(scope, element, attrs) {
      var updateTime;

      updateTime = function() {
        var m;

        m = moment();
        return element.html(m.format(attrs.format || 'dddd, MMMM DD YYYY, h:mm:ss'));
      };
      return setInterval(updateTime, 1000);
    };
  });

  myDirectives.directive('trackersCount', function() {
    return function(scope, element, attrs) {
      return scope.$watch('trackers', function(trackers) {
        var active, all;

        all = trackers != null ? trackers.length : void 0;
        active = _.filter(trackers, function(t) {
          return t.active;
        }).length;
        element.html(all);
        element.parent().tooltip('destroy');
        return element.parent().tooltip({
          html: true,
          title: "Active: " + active + "\nNot active: " + (all - active)
        });
      });
    };
  });

  geocode = ['$http'];

  geocode.push(function($http) {
    return function(scope, element, attrs) {
      var langs, url;

      url = 'http://geocode-maps.yandex.ru/1.x/?kind=' + (attrs.kind || 'house') + '&results=1&format=json&geocode=';
      langs = {
        uk: 'uk-UA',
        ru: 'ru-RU',
        en: 'en-US'
      };
      return scope.$watch(attrs.geocode, function(c) {
        var promise;

        if (!c) {
          return;
        }
        promise = $http.get("" + url + c.lng + "," + c.lat + "&lang=" + langs[navigator.language]);
        return promise.then(function(res) {
          var description, street;

          street = res.data.response.GeoObjectCollection.featureMember[0].GeoObject.name;
          description = res.data.response.GeoObjectCollection.featureMember[0].GeoObject.description;
          element.html(street);
          element.tooltip('destroy');
          return element.tooltip({
            html: true,
            title: description
          });
        });
      });
    };
  });

  myDirectives.directive('geocode', geocode);

  myDirectives.directive('tooltip', function() {
    return function(scope, element, attrs) {
      return attrs.$observe('tooltip', function(title) {
        element.tooltip('destroy');
        return element.tooltip({
          title: title
        });
      });
    };
  });

  myDirectives.directive('direction', function() {
    return function(scope, element, attrs) {
      return scope.$watch(attrs.direction, function(direction) {
        if (!direction) {
          return;
        }
        return element.css({
          rotate: direction
        });
      });
    };
  });

  myDirectives.directive('status', function() {
    return function(scope, element, attrs) {
      return scope.$watch(attrs.status, function(status) {
        if (!status) {
          return;
        }
        return element.attr('class', 'status ' + status);
      });
    };
  });

}).call(this);
